<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Daniel Standage</title><link href="https://standage.github.io/" rel="alternate"></link><link href="https://standage.github.io/feeds/blog.atom.xml" rel="self"></link><id>https://standage.github.io/</id><updated>2015-12-16T00:00:00-05:00</updated><entry><title>Misconceptions about research software</title><link href="https://standage.github.io/misconceptions-about-research-software.html" rel="alternate"></link><updated>2015-12-16T00:00:00-05:00</updated><author><name>Daniel S. Standage</name></author><id>tag:standage.github.io,2015-12-16:misconceptions-about-research-software.html</id><summary type="html">&lt;p&gt;I stumbled across &lt;a href="https://www.quora.com/I-have-5-years-of-working-experience-but-I-still-code-very-slow-How-can-I-code-faster-What-should-I-learn"&gt;the following question&lt;/a&gt; the other day in an email digest from Quora.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I have 5 years of working experience, but I still code very slow.
How can I code faster? What should I learn?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Most of the responses don't answer the question directly, but instead make the point that speed is a very poor metric by which to measure quality or productivity in software engineering.
Carefully designing, documenting, implementing, and testing code requires considerable time and resources upfront, but not nearly as much time and resources as is required in later stages to maintain or fix code that was written quickly and sloppily.&lt;/p&gt;
&lt;p&gt;In this case, I think the &lt;a href="http://meta.stackexchange.com/a/146514/151867"&gt;OP&lt;/a&gt; fell into the trap of thinking that writing code is just about writing code.
In reality, code is just a projection of a programmer's conceptual model of something onto a representation that a computer can interpret and execute.
If your initial conceptual model is clear, your code will be clear and easy to write.
If your initial conceptual model is fuzzy, you'll probably end up taking the long way to a workable solution, leaving lots of crufty code in your wake.
Research software engineering is so much more than just "writing code".&lt;/p&gt;
&lt;p&gt;In the ideal situation (i.e., with a clear and accurate mathematical model in hand, and with informed choices about which algorithms and data structures provide an efficient computational solution), writing the actual code is almost an afterthought.
Once the model is nailed down, the programmer has quite a bit of technical freedom when it comes to implementation and testing, but the precise details of implementation are of little interest compared to the results produced by the software.&lt;/p&gt;
&lt;p&gt;In the real world, I get the impression that most programmers and programmer-scientists rarely achieve this ideal, and end up developing and refining their models &lt;em&gt;as they write the code&lt;/em&gt;.
I think some of this has to do with lack of discipline, which each scientist has to address on a personal level.
I think it also has to do with lack of training, of which I think we could be doing much better job as a field.&lt;/p&gt;
&lt;p&gt;But I think the notion (all too common in academics) that research software engineering is a technical exercise ("just writing code") rather than an intellectual one is particularly problematic.
It's problematic for those that create the software, who all too often jump head-first into &lt;em&gt;writing code&lt;/em&gt; without having done the proper modeling and design upfront.
It's problematic for those in a position to supervise or evaluate or fund research, who all too often trivialize software because it's "just writing code".&lt;/p&gt;
&lt;p&gt;A few months ago the bioinformatics twittersphere/blogosphere got caught up in a great discussion on the purpose of software in academic research.
I was able to dig through some old notes and find a link to &lt;a href="http://phdops.kblin.org/software-dev-intellectual-contribution.html"&gt;an excellent blog post&lt;/a&gt; which provides links to lots of good reading on the topic.
I particularly like the analogy he made between experiments (design vs execution) and software (design vs implementation).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Software development in science is often compared to conductiong [sic] experimental work, and because most people argue that experimental work is a means to an end, that is not a primary product of science.
So, by analogy, neither should software development be.
The actual &lt;em&gt;scientific&lt;/em&gt; contribution is designing the experiment in the first place.
Now, the analogy has one slight problem here, and I'm tempted to blame that problem on the pretty shoddy practices around software development in science, people have written about this before.
Mainly, people seem to assume that &lt;strong&gt;implementing&lt;/strong&gt; the software is all there is for software development.
I humbly disagree.
I would argue that the analogy with wet lab work would be that &lt;strong&gt;designing experiments&lt;/strong&gt; is like &lt;strong&gt;designing software&lt;/strong&gt;, and &lt;strong&gt;conducting experiments&lt;/strong&gt; is like &lt;strong&gt;implementing software&lt;/strong&gt;.
Now if we follow the general agreement that designing experiments is a valuable intellectual input to the scientific endeavour, by analogy so should designing software.
So, the answer the question I asked in the topic of the post "Is software development in science an intellectual contribution?" would be "Yes, parts of it at least".&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I agree: the design of research software should be treated as a valid intellectual contribution in the academic science enterprise, and credit should be rendered accordingly.&lt;/p&gt;</summary><category term="software"></category><category term="academics"></category><category term="credit"></category></entry><entry><title>Shell pipelines in Python</title><link href="https://standage.github.io/shell-pipelines-in-python.html" rel="alternate"></link><updated>2015-12-15T00:00:00-05:00</updated><author><name>Daniel S. Standage</name></author><id>tag:standage.github.io,2015-12-15:shell-pipelines-in-python.html</id><summary type="html">&lt;p&gt;The UNIX shell is an indispensible tool for project organization and data management in bioinformatics.
I spend &lt;em&gt;a lot&lt;/em&gt; of time in the shell, and having picked up on a lot of time-saving techniques over the years it might just be my favorite computing environment.&lt;/p&gt;
&lt;p&gt;The shell has its limitations, however.
Piping, the very feature that gives the shell its amazing power and flexibility, can also lead to some pretty gruesome syntax.
Debugging shell code is tough, the error handling is rudimentary, and good luck finding a good framework for automated tests.
In short, the shell is great for interactive computing and automating simple tasks, but when it comes to workflows requiring more fine-grained control, a language like Python is often a better choice.&lt;/p&gt;
&lt;p&gt;Here I provide a Python translation of several shell commands.&lt;/p&gt;
&lt;h2&gt;Simplest case&lt;/h2&gt;
&lt;p&gt;You don't typically get much bioinformatics work done with a single command without arguments.
Anything substantial will involve data files, parameters, and so on, that are typically specified using arguments on the command line (you don't have these hard coded in a script, do you?!?!).
But just for sake of completeness, it's very straightforward to execute shell commands this way in Python.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ls
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Python equivalent is as follows.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ls&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is even the simpler &lt;code&gt;call&lt;/code&gt; function...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ls&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...but for most situations I find the &lt;code&gt;check_call&lt;/code&gt; more useful, since it will halt the Python code immediately if the subprocess returns a non-zero status.&lt;/p&gt;
&lt;h2&gt;Command with arguments&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ls -lhp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Commands with arguments cannot simply be dropped in to the &lt;code&gt;check_call&lt;/code&gt; command as-is.
The following code will fail.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ls -lhp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There are two ways you can fix this: the convenient (and wrong and insecure) way...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ls -lhp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...and The Right Way.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_call&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ls&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-lhp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The convenience of the first method comes at the cost of security: the &lt;code&gt;shell=True&lt;/code&gt; setting introduces vulnerability to &lt;a href="https://security.openstack.org/guidelines/dg_use-subprocess-securely.html"&gt;shell injections&lt;/a&gt;.
This isn't the type of thing you expect to encounter much in the research setting, but it's an important consideration nonetheless, and exceptions should be made with caution.&lt;/p&gt;
&lt;p&gt;This example is pretty silly, since you'll probably never need to call the &lt;code&gt;ls&lt;/code&gt; command from Python.
Let's do a different example you're much more likely to encounter in bioinformatics.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;blastx -db /opt/ncbi/nr -query tsa.fasta &lt;span class="se"&gt;\&lt;/span&gt;
       -evalue 1e-4 -num_threads &lt;span class="nv"&gt;$numthreads&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
       -out tsa-vs-nr.blastx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Python equivalent is as follows.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;blastx&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-db&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;/opt/ncbi/nr&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-query&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;tsa.fasta&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="s"&gt;&amp;#39;-evalue&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;1e-4&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-num_threads&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;numthreads&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="s"&gt;&amp;#39;-out&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;tsa-vs-nr.blastx&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Redirect stdin and stdout&lt;/h2&gt;
&lt;p&gt;Many programs and commands allow you to specify input and output files as arguments, as in the &lt;code&gt;blastx&lt;/code&gt; command above.
However, sometimes your only options are &lt;code&gt;stdin&lt;/code&gt; and/or &lt;code&gt;stdout&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sed s/^scaffold_/PcanScaf/ &amp;lt; pcan-in.gff3 &amp;gt; pcan-out.gff3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here is the Python equivalent.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;pcan-in.gff3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;instream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;pcan-out.gff3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;outstream&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_call&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;sed&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;s/^scaffold_/PcanScaf/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;instream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;outstream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;The main event: pipelines&lt;/h2&gt;
&lt;p&gt;Handling input and output for single commands is great and all, but the real power of the shell is piping commands together like so.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grep -v &lt;span class="s1"&gt;$&amp;#39;\tintron\t&amp;#39;&lt;/span&gt; loci.gff3 &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="p"&gt;|&lt;/span&gt; pmrna --locus --accession --map&lt;span class="o"&gt;=&lt;/span&gt;map.txt &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="p"&gt;|&lt;/span&gt; canon-gff3 --outfile&lt;span class="o"&gt;=&lt;/span&gt;locus.mrnas.gff3 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Unless we want to introduce security vulnerabilities, we cannot simply run these commands with a single call to the &lt;code&gt;check_call&lt;/code&gt; function.
For this use case, we want to use the &lt;code&gt;Popen&lt;/code&gt; constructor and the &lt;code&gt;communicate&lt;/code&gt; method.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;grepproc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;grep&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-v&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s"&gt;intron&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;loci.gff3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                             &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PIPE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;pmrnaproc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;pmrna&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--locus&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--accession&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--map=map.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                             &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;grepproc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                             &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PIPE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;canonproc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;canon-gff3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--outfile=locus.mrnas.gff3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                             &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pmrnaproc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;canonproc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;communicate&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If needed, it is trivial to capture the terminal output like so.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;grepproc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;grep&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-v&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s"&gt;intron&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;loci.gff3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                             &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PIPE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;pmrnaproc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;pmrna&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--locus&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--accession&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--map=map.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                             &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;grepproc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                             &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PIPE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;canonproc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;canon-gff3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--outfile=locus.mrnas.gff3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                             &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pmrnaproc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                             &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PIPE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                             &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PIPE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;canonproc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;communicate&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c"&gt;# process the terminal warnings&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Coda&lt;/h2&gt;
&lt;p&gt;That's it!&lt;/p&gt;
&lt;p&gt;Python's &lt;code&gt;subprocess&lt;/code&gt; module is pretty powerful, and allows even slicker interactions with the shell, such as printing text to a pipeline of shell commands.
However, writing to and reading from a pipeline simultaneously can get tricky and is prone to deadlocks.
I will not cover this here, but the Internet is full of blog posts and StackOverflow threads discussing the intricacies of the &lt;code&gt;subprocess&lt;/code&gt; for these more complicated use cases.&lt;/p&gt;</summary><category term="shell"></category><category term="python"></category></entry><entry><title>Filter stderr while piping in UNIX</title><link href="https://standage.github.io/filter-stderr-while-piping-in-unix.html" rel="alternate"></link><updated>2015-12-14T00:00:00-05:00</updated><author><name>Daniel S. Standage</name></author><id>tag:standage.github.io,2015-12-14:filter-stderr-while-piping-in-unix.html</id><summary type="html">&lt;p&gt;I've written before about &lt;a href="https://biowize.wordpress.com/2013/10/11/commands-in-place-of-program-arguments/"&gt;process substitutions in the shell&lt;/a&gt;.
This has become a core technique I use almost on a daily basis in my data work in the shell.
It has many uses, but I want to highlight a particular one here.&lt;/p&gt;
&lt;h2&gt;Use case&lt;/h2&gt;
&lt;p&gt;Imagine you have a shell script with the following commands&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;first_command --arg1&lt;span class="o"&gt;=&lt;/span&gt;foo --arg2&lt;span class="o"&gt;=&lt;/span&gt;bar --flag3 infile.txt &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="p"&gt;|&lt;/span&gt; second_command one two three &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="p"&gt;|&lt;/span&gt; third_command --abc xyz &lt;span class="se"&gt;\&lt;/span&gt;
    &amp;gt; outfile.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Each of these commands will print to stderr in case of a warning or an error.
However, &lt;code&gt;second_command&lt;/code&gt; prints an irrelevant warning (&lt;code&gt;cannot find "foo"&lt;/code&gt;) message over and over again, filling up the terminal with thousands of lines of noise and making it more difficult to find warnings or error messages we might actually care about.
How can we filter the stderr of &lt;code&gt;second_command&lt;/code&gt; so that the &lt;code&gt;cannot find "foo"&lt;/code&gt; messages are ignored, but all other messages still show up?&lt;/p&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;p&gt;Process substitutions can be used not only as pseudo input files using the &lt;code&gt;&amp;lt;()&lt;/code&gt; syntax, but also as pseudo output files using the &lt;code&gt;&amp;gt;()&lt;/code&gt; syntax.
If we redirect a program's output to a process, we can then filter the data within that process, like so.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;some_program &amp;gt; &amp;gt;&lt;span class="o"&gt;(&lt;/span&gt;sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Extending this to stderr requires only two changes.
First, we replace &lt;code&gt;&amp;gt;&lt;/code&gt; with &lt;code&gt;2&amp;gt;&lt;/code&gt; so that we are redirecting the correct output stream.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;some_program 2&amp;gt; &amp;gt;&lt;span class="o"&gt;(&lt;/span&gt;sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Secondly, we add &lt;code&gt;1&amp;gt;&amp;amp;2&lt;/code&gt; to the end of the process so that its stdout is redirected back to stderr, which is where the data was intended to go in the first place (cue Ghostbusters quote about not crossing the streams).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;some_program 2&amp;gt; &amp;gt;&lt;span class="o"&gt;(&lt;/span&gt;sort &lt;span class="p"&gt;|&lt;/span&gt; uniq -c 1&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;2&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Putting this all together and going back to our original use case, we can remove the unwanted &lt;code&gt;cannot find "foo"&lt;/code&gt; messages from our terminal like so.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;first_command --arg1&lt;span class="o"&gt;=&lt;/span&gt;foo --arg2&lt;span class="o"&gt;=&lt;/span&gt;bar --flag3 infile.txt &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="p"&gt;|&lt;/span&gt; second_command one two three 2&amp;gt; &amp;gt;&lt;span class="o"&gt;(&lt;/span&gt;grep &lt;span class="s1"&gt;&amp;#39;cannot find &amp;quot;foo&amp;quot;&amp;#39;&lt;/span&gt; 1&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;2&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="p"&gt;|&lt;/span&gt; third_command --abc xyz &lt;span class="se"&gt;\&lt;/span&gt;
    &amp;gt; outfile.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That's it!&lt;/p&gt;</summary><category term="shell"></category></entry><entry><title>Consortium authors in EndNote</title><link href="https://standage.github.io/consortium-authors-in-endnote.html" rel="alternate"></link><updated>2015-11-21T00:00:00-05:00</updated><author><name>Daniel S. Standage</name></author><id>tag:standage.github.io,2015-11-21:consortium-authors-in-endnote.html</id><summary type="html">&lt;p&gt;Today I was reformatting a manuscript and changing from a numbered citation style to an author/date citation style.
In doing so, I found some issues with my EndNote references library that had gone unnoticed before since they were tucked away in the reference list.
One of the issues involved citation of a paper with a single consortium author, designated in the library as &lt;strong&gt;Honeybee_Genome_Sequencing_Consortium&lt;/strong&gt;.
I wasn't clear why it was formatted this way until I tried to fix the author field, and the citation then became &lt;strong&gt;Consortium HGS&lt;/strong&gt;, as if this was a person's name.
Neither the underscores nor the initials were satisfactory, so I decided to see if the Internet's collective wisdom (i.e. Google) had any light to shed on the issue.&lt;/p&gt;
&lt;p&gt;It turns out that one way (the way?) to solve this issue is to type the consortium name as you want it to appear, and then append a comma at the end (in my case, &lt;strong&gt;Honeybee Genome Sequencing Consortium,&lt;/strong&gt;).
This tricks EndNote into thinking this is a surname, and thus it does not attempt to initialize the name.
Perhaps there's a cleaner way, but this worked for me!&lt;/p&gt;
&lt;p&gt;Hat tip to the University of Warwick for &lt;a href="http://blogs.warwick.ac.uk/endnoteweb/entry/entering_names_of/"&gt;this blog post&lt;/a&gt;!&lt;/p&gt;</summary><category term="endnote"></category><category term="formatting"></category></entry><entry><title>New lab notebook setup: my motivation</title><link href="https://standage.github.io/new-lab-notebook-setup-my-motivation.html" rel="alternate"></link><updated>2015-11-17T00:00:00-05:00</updated><author><name>Daniel S. Standage</name></author><id>tag:standage.github.io,2015-11-17:new-lab-notebook-setup-my-motivation.html</id><summary type="html">&lt;p&gt;My first research blog was a self-hosted Wordpress blog run from an Ubuntu server in our lab.
I was initially enamored by the supposed control and flexibility this gave me, but when I changed institutions a year or so later I was not quite as enamored with the work that went into migrating the content, nor the time I spent in sysadmin troubleshooting (I hate SELinux with a passion).
During that time I had also become familiar with the disheartening statistics on the half-life of links to academic department/lab websites.
I so decided that in the long run it would be more sustainable for me to let someone else handle the hosting concerns, so I could focus just on the content.
Version 2 of my blog was (well, is) &lt;a href="http://biowize.wordpress.com"&gt;hosted at Wordpress.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I've continued posting content to the blog over the last couple of years—though not as frequently as I would like—but recently I've become increasingly dissatisfied.
I found myself saving electronic "scribbles" in Evernote or my wiki (also self-hosted on a server in our lab) and IPython/Jupyter notebooks in GitHub gists, saving the blog for when I really wanted to stretch my writing legs and produce some polished, contextualized thoughts.
But with notes and code and blog posts scattered all over the place, my setup felt harried and scrambled.
I need a more organized and streamlined solution.&lt;/p&gt;
&lt;p&gt;In working out the setup for this notebook, I have the following considerations in mind.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;One-stop shop&lt;/strong&gt;. With the exception of my software engineering work (which benefits immensely from the development workflow provided by git and GitHub), I want to be able to store all of my notes, scribbles, code snippets, Jupyter notebooks, and blog posts in one convenient location.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Markdown support&lt;/strong&gt;. I was never a fan of web-based WYSIWYG text editors, and so I've been writing all of my blog content in raw HTML.
  It's a travesty that this is still happening in 2015.
  I would much prefer to format my content with Markdown.
  (Ironically, I just learned recently that Wordpress.com now has integrated support for Markdown, so this would make a poor excuse if it was my only reason for changing.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embedded JavaScript&lt;/strong&gt;. Wordpress.com does not allow users to embed &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in blog posts.
  "Shortcodes" are available for embedding content from a variety of popular media sources (Youtube, GitHub gist, and Twitter, for example), but you're out of luck if you want to embed video or other rich content from a different source (such as an &lt;a href="https://asciinema.org/"&gt;asciicast&lt;/a&gt;).
  Support for embedded JavaScript is high on my priority list for this new setup.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Control and accessibility&lt;/strong&gt;. The first self-hosted version of the blog gave me the illusion of control and accessibility with respect to content, but really I was stuck to the web authoring interface (behind the scenes it was raw HTML stored in a MySQL database, and I wanted nothing to do with that bidness).
  The second version of my blog relieved me of the tedium of hosting, but only by relinquishing even more accessibility and control over my content.
  For my new setup, I would like the ability to write my content in vim or Komodo Edit; to search the content with shell tools or with custom Python scripts; to set up automated backup procedures using cron.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Taking all this into account, it's pretty clear that I need a solution based on a &lt;a href="https://wiki.python.org/moin/StaticSiteGenerator"&gt;static site generator&lt;/a&gt;.&lt;/p&gt;</summary><category term="meta"></category></entry><entry><title>Hello, world!</title><link href="https://standage.github.io/hello-world.html" rel="alternate"></link><updated>2015-11-16T00:00:00-05:00</updated><author><name>Daniel S. Standage</name></author><id>tag:standage.github.io,2015-11-16:hello-world.html</id><summary type="html">&lt;p&gt;Seed content for my new notebook.&lt;/p&gt;</summary><category term="meta"></category></entry></feed>